#include <stdlib.h>
#include <assert.h>
#include "thread.h"

#define MAX_THREADS 1024
#define STACK_SIZE  4096

typedef struct Thread_T {
    
    int id;                    
    char *stack; 
    // _start() ;         
    int (*func)(void *);       
    void *args;                
    int return_value;          
    struct Thread_T *next;     
} Thread_T;

// check if (Start<= PC <= End) return;
    // where Start=thread.o sem.o chan.o switch.o=End
    //      |________________________________________|
//  Thread_new
    // _start()
    // ....
    // out=1;
    // malloc();
    // out=0;

    // ...
// pre_emption() -> sigset(handler) (περιοδικό σήμα)
// |
// V
// handler()
// {
    // _pause();
    // _enable();
// }

// T_lock(){
// critical section
//     while (locked)
//     {
        // pause();
//     }
//     locked<-1;
// end critical section
// }

// T_unlock(){
//     locked<-0;
// enq(deq(l->q), readyQ);
// }

static Thread_T *thread_pool[MAX_THREADS];  
static Thread_T *ready_queue = NULL;        
static Thread_T *current_thread = NULL;     
static int num_threads = 0;

extern void _swtch(void *from, void *to);

static void enqueue(Thread_T **queue, Thread_T *t);
static Thread_T *dequeue(Thread_T **queue);
static void thread_stub(void);

void Thread_init(void) {
    current_thread = malloc(sizeof(Thread_T));
    assert(current_thread);
    current_thread->id = num_threads++;
    current_thread->stack = NULL;
    current_thread->func = NULL;
    current_thread->args = NULL;
    current_thread->return_value = 0;
    current_thread->next = NULL;

    thread_pool[current_thread->id] = current_thread;
}

int Thread_new(int func(void *), void *args, size_t nbytes, ...) {
    Thread_T *new_thread = malloc(sizeof(Thread_T));
    assert(new_thread);

    new_thread->id = num_threads++;
    new_thread->func = func;
    new_thread->args = args;
    new_thread->stack = malloc(STACK_SIZE);  
    assert(new_thread->stack);

    new_thread->next = NULL;
    enqueue(&ready_queue, new_thread);

    thread_pool[new_thread->id] = new_thread;
    return new_thread->id;
}

void Thread_exit(int code) {
    current_thread->return_value = code;
    free(current_thread->stack);
    free(current_thread);

    current_thread = dequeue(&ready_queue);
    if (current_thread) {
        _swtch(NULL, current_thread);
    } else {
        exit(0);  // No more threads to run
    }
}

int Thread_self(void) {
    return current_thread ? current_thread->id : -1;
}

int Thread_join(int tid) {
    Thread_T *target = thread_pool[tid];
    assert(target);

    while (target && target->stack) {
        Thread_pause();
    }

    return target->return_value;
}

void Thread_pause(void) {
    Thread_T *old_thread = current_thread;
    current_thread = dequeue(&ready_queue);
    
    printf("Thread old %d pause \n", old_thread->id );
    printf("Thread current_thread %d pause \n", current_thread->id );
    if (current_thread) {
        enqueue(&ready_queue, old_thread);  
        _swtch(old_thread, current_thread); 
    }
    printf("Thread current_thread %d pause \n", current_thread->id );
}

static void enqueue(Thread_T **queue, Thread_T *t) {
    t->next = NULL;
    if (*queue == NULL) {
        *queue = t;
    } else {
        Thread_T *temp = *queue;
        while (temp->next) {
            temp = temp->next;
        }
        temp->next = t;
    }
}

static Thread_T *dequeue(Thread_T **queue) {
    if (*queue == NULL) {
        return NULL;
    } else {
        Thread_T *t = *queue;
        *queue = (*queue)->next;
        return t;
    }
}

static void thread_stub(void) {
    Thread_exit(current_thread->func(current_thread->args));
}
